# 애자일 설계

> Agile Software Development - Principles, Patterns, and Practices - 로버트 마틴 (번역서: 클린 소프트웨어, PPP라고도 불림)

애자일 설계란 무엇인가?
애자일 설계는 과정이지, 결과가 아니다.
이것은 원칙, 패턴, 그리고 소프트웨어의 구조와 가독성을 향상시키기 위한 방식의 연속적인 적용이다.
모든 시점에서 시스템의 설계를 가능한 한 간단하고, 명료하고, 표현적으로 유지하려는 노력이다.

애자일 팀에서, 큰 그림은 소프트웨어와 함께 발전한다.
각 반복에서 팀은 시스템의 설계를 개선해 지금 그대로도 충분히 가능한 한 제일 좋은 시스템이 되도록 한다.
나중의 요구사항과 필요에 대해서는 그리 오래 생각하지 않는다.
그리고 내일 필요해질 것이라고 생각하는 기능을 지원하기 위해 오늘 기반구조(infrastructure)를 짜 맞추려 하지도 않는다.
그보다는, 현재 구조에 초점을 두고 더욱 개선하기 위해 노력한다.

- [애자일 설계](#애자일-설계)
  - [가능한 한 좋은 상태로 설계 유지하기](#가능한-한-좋은-상태로-설계-유지하기)
  - [잘못된 설계의 증상](#잘못된-설계의-증상)
    - [경직성(Rigidity)](#경직성rigidity)
    - [취약성(Fragility)](#취약성fragility)
    - [부동성(Immobility)](#부동성immobility)
    - [점착성(Viscosity)](#점착성viscosity)
    - [불필요한 복잡성(Needless Complexity)](#불필요한-복잡성needless-complexity)
    - [불필요한 반복(Needless Repetition)](#불필요한-반복needless-repetition)
    - [불투명성(Opacity)](#불투명성opacity)
  - [객체 지향 설계 원칙](#객체-지향-설계-원칙)
    - [단일 책임 원칙(`SRP`, Single Responsibility Principle)](#단일-책임-원칙srp-single-responsibility-principle)
    - [개방 폐쇄 원칙(`OCP`, Open-Closed Principle)](#개방-폐쇄-원칙ocp-open-closed-principle)
    - [리스코프 치환 원칙(`LSP`, Liskov Substitution Principle)](#리스코프-치환-원칙lsp-liskov-substitution-principle)
    - [의존 관계 역전 원칙(`DIP`, Dependency Inversion Principle)](#의존-관계-역전-원칙dip-dependency-inversion-principle)
    - [인터페이스 분리 원칙(`ISP`, Interface Segregation Principle)](#인터페이스-분리-원칙isp-interface-segregation-principle)

## 가능한 한 좋은 상태로 설계 유지하기

애자일 개발자는 설계를 가능한 한 적절하고 명료한 상태로 유지하기 위해 애쓴다.
이것은 생각 없이 하거나 시험 삼아 해보는 약속이 아니다.
애자일 개발자는 몇 주마다 한 번씩 설계를 '청소(clean up)'하지 않는다.
그렇기는커녕 매일, 매시간, 심지어 분마다 소프트웨어를 가능한 한
명료하고, 간단하고, 표현적인 상태로 유지한다.
그들은 "집에 갈래. 저건 나중에 고치지 뭐."라고 말하는 일이 없으며,
절대 부패가 시작되도록 놔두지 않는다.

애자일 개발자가 소프트웨어의 설계에 보이는 태도는
외과 의사가 살균 절차에 보이는 태도와 똑같다.
살균 절차는 수술을 가능하게 만들어주는 것으로,
살균 절차가 없다면 감염의 위험성은 용인할 수 있는 수준을 한참 넘어설 것이다.
애자일 개발자는 자신의 설계에 대해 이와 같은 태도를 취한다.
심지어 가장 작은 비트 단위의 부패라도 시작되도록 방치하면 나중에는 감당할 수 없을 만큼 위험이 커질 것이다.

설계는 명료한 상태로 유지되어야 한다.
그리고 설계의 가장 중요한 표현인 소스 코드 역시 명료한 상태로 유지되어야 한다.
전문가적인 정신에 따라, 우리는 소프트웨어 개발자로서 코드가 부패되도록 내버려둘 수 없다.

## 잘못된 설계의 증상

이 증상들은 본질적으로 '코드의 악취(code smell)'와 비슷하지만, 좀 더 높은 단계에서의 문제다.
이 악취는 코드의 작은 부분이 아니라 소프트웨어의 전체 구조로 고루 퍼져 나간다.
대개 이런 악취들은 하나 이상의 원칙을 위반했을 때 발생한다.

### 경직성(Rigidity)

- 설계를 변경하기 어렵다.
- 변경을 하려면 시스템의 다른 부분들까지 많이 변경해야 하기 때문이다.

### 취약성(Fragility)

- 설계가 망가지기 쉽다.
- 변경을 하면 시스템에서 그 부분과 개념적으로 아무 관련 없는 부분이 망가진다.

### 부동성(Immobility)

- 설계를 재사용하기 어렵다.
- 시스템을 다른 시스템에서 재사용할 수 있는 컴포넌트로 구분하기가 어렵다.
- 다른 시스템에서 유용하게 쓸 수 있는 부분을 포함하고 있지만,
  그런 부분을 원래 시스템에서 분리하는 수고와 위험성이 지나치게 클 때
  설계는 움직이게 할 수 없다.

### 점착성(Viscosity)

- 제대로 동작하기 어렵다.
- 옳은 동작을 하는 것이 잘못된 동작을 하는 것보다 더 어렵다.

### 불필요한 복잡성(Needless Complexity)

- 과도한 설계를 가지고 있다.
- 직접적인 효용이 전혀 없는 기반구조가 설계에 포함되어 있다.

### 불필요한 반복(Needless Repetition)

- 마우스 남용.
- 단일 추상 개념으로 통합할 수 있는 반복적인 구조가 설계에 포함되어 있다.
- '잘라내기'와 '붙이기'는 쓸모 있는 텍스트 편집 작업이 될 수도 있겠지만,
  피해가 막심한 코드 편집 작업이 될 수도 있다.
  너무나도 흔하게, 소프트웨어 시스템은 몇십, 몇백개의 반복된 코드 요소로 구성된다.
- 시스템에 반복되는 코드가 존재할 때, 시스템을 변경하는 일은 고될 수 있다.

### 불투명성(Opacity)

- 읽고 이해하기 어렵다.
- 혼란스러운 표현.
- 그 의도를 잘 표현하지 못한다.

## 객체 지향 설계 원칙

> [The Principle of OOD](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod) - UncleBob.com

### 단일 책임 원칙(`SRP`, Single Responsibility Principle)

> 한 클래스는 단 한 가지의 변경 이유만을 가져야 한다.

- 톰 드마르코(Tom DeMarco)와 메이릴 페이지 존스(Meilir Page-JOnes)의 연구에서 설명된 것으로,
  그들은 이것을 응집도(cohesion)라 불렀다.
  그들은 응집도를 모듈 요소 간의 기능적인 연관으로 정의했지만,
  여기에서는 모듈이나 클래스의 변경을 야기하는 응집력을 설명한다.
- SRP의 맥락에서, 책임(responsibility)을 '변경을 위한 이유'로 정의한다.

### 개방 폐쇄 원칙(`OCP`, Open-Closed Principle)

> 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

- 확장에 대해 열려 있다.
  - 이것은 모듈의 행위가 확장될 수 있음을 의미한다.
- 수정에 대해 닫혀 있다.
  - 어떤 모듈의 행위를 확장하는 것이 그 모듈의 소스 코드나 바이너리 코드의 변경을 초래하지 않는다.
- 해결책은 추상화다.
- 하지만 애플리케이션의 모든 부분에 마구 추상화를 적용하는 것도 좋은 생각이 아니다.
  그보다는, 프로그램에서 자주 변경되는 부분에만 추상화를 적용하기 위한 개발자의 헌신이 필요하다.
- 어설픈 추상화를 피하는 일은 추상화 자체만큼이나 중요하다.

### 리스코프 치환 원칙(`LSP`, Liskov Substitution Principle)

> 서브타입(subtype)은 서브 타입의 기반 타입(base type)으로 치환 가능해야 한다.

- LSP는 OCP를 가능하게 하는 주요 요연 중 하나다.
  이것은 기반 타입으로 표현된 모듈을 수정 없이도 확장 가능하게 만드는,
  서브타입의 치환 가능성을 말한다.
- 이 치환 가능성은 개발자가 암암리에 의존할 수 있는 그 어떤 것이 되어야 한다.
  따라서 기반 타입의 계약사항은 명시적으로 강제되지 않은 경우,
  코드에서 분명하고 뚜렷해야 한다.

### 의존 관계 역전 원칙(`DIP`, Dependency Inversion Principle)

> 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다.
> 둘 모두 추상화에 의존해야 한다.

> 추상화는 구체적인 사항에 의존해서는 안 된다.
> 구체적인 사항은 추상화에 의존해야 한다.

### 인터페이스 분리 원칙(`ISP`, Interface Segregation Principle)

> 클라이언트가 자신이 사용하지 않는 메서드에 의존하도록 강제되어서는 안 된다.

- ISP는 응집력이 없는 인터페이스를 필요로 하는 객체가 있다는 것을 인정하지만,
  클라이언트는 그것을 하나의 단일 클래스로 생각해서는 안 됨을 시사한다.
  오히려, 클라이언트는 응집력이 있는 인터페이스를 가지는 추상 기반 클래스에 대해 알고 있어야 한다.
